<?php

namespace App\Http\Controllers\Web;

use App\Http\Controllers\Controller;
use App\Models\Order;
use Illuminate\Http\Request;
use GuzzleHttp\Client;
use Illuminate\Support\Facades\Validator;
use Stripe\Charge;
use Stripe\PaymentIntent;
use Stripe\Stripe;
use Stripe\StripeClient;

class PaymentController extends Controller
{
    private $stripe;
    public function __construct()
    {
        $this->stripe = new StripeClient(env('STRIPE_SECRET_KEY'));
    }
    public function payment($order_id, $amount, $billingParams)
    {
            // Fetch order details
            $order = Order::findOrFail($order_id);
            Stripe::setApiKey(env('STRIPE_SECRET_KEY'));
            $paymentIntent = PaymentIntent::create([
                'payment_method_types' => ['card'],
                'amount' => max(200,  intval($amount * 100)), // Adjust amount as needed
                'currency' => 'AED', // Adjust currency as needed
                'description' => 'Order of: ' . $billingParams['first_name'] . ' with order id ' . $order_id,
            ]);

            // Extract payment intent ID
            $paymentIntentId = $paymentIntent->id;

            $redirectUrl = route('processPayment', ['paymentIntentId' => $paymentIntentId]);
        
            return ($redirectUrl);
    }

    public function processPayment(Request $request)
    {
       
        Stripe::setApiKey(env('STRIPE_SECRET_KEY'));
        try {
            $charge = Charge::create([
                'amount' => 2000, // Example amount in cents ($20.00)
                'currency' => 'usd', // Example currency
                'source' => $request->stripeToken, // Token generated by Stripe.js
                'description' => 'Example Charge', // Example description,
                
            ]);
            $paymentIntent = PaymentIntent::retrieve($request->paymentIntentId);
            dd($paymentIntent);
            $paymentIntent->confirm();
            // Payment successful
            if ($request->has('stripeStatus') && $request->stripeStatus === 'succeeded') {
               $response = app(CartController::class)->order_success(1);
                return redirect(url($response['data'])); 
            } else {
                $response = app(CartController::class)->order_payment_failed(1);
                return redirect(url($response['data']));
            }
        } catch (\Exception $e) {
            // Payment failed
            dd($e);
            return redirect()->back()->with('error', $e->getMessage());
        }
 
        return response()->redirectTo('/');
    }
    private function createToken($cardData)
    {
 
        $token = null;
        try {
            $token = $this->stripe->tokens->create([
                'card' => [
                    'number' => $cardData['cardNumber'],
                    'exp_month' => $cardData['month'],
                    'exp_year' => $cardData['year'],
                    'cvc' => $cardData['cvv']
                ]
            ]);
        } catch (CardException $e) {
            $token['error'] = $e->getError()->message;
        } catch (Exception $e) {
            $token['error'] = $e->getMessage();
        }
        return $token;
    }
    public function charge(Request $request)
    {
        $paymentIntentId = request()->paymentIntentId;
       
            return view('web.payment', compact('paymentIntentId'));
       
       
        // Handle payment success
        // You can implement this method according to your business logic
    }

    public function paymentCancel(Request $request)
    {
        $response = app(CartController::class)->order_payment_cancelled(1);
        
        return redirect(url($response['data']));
        // Handle payment cancellation
        // You can implement this method according to your business logic
    }

    public function paymentDeclined(Request $request)
    {
        $response = app(CartController::class)->order_payment_failed(1);

        return redirect(url($response['data']));
    }
}
